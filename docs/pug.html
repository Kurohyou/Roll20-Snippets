<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="crossorigin"/>
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&amp;family=Exo+2:ital,wght@0,400;0,700;1,400&amp;family=Fira+Code&amp;display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
    <link rel="stylesheet" href="assets/portfolio/social-icons.css"/>
    <link rel="stylesheet" href="./assets/css/clear.css"/>
    <link rel="stylesheet" href="./assets/css/generic.css"/>
    <link rel="stylesheet" href="./assets/css/prettify.css"/>
    <link rel="stylesheet" href="./assets/css/sons-of-obsidian.css"/>
    <link rel="stylesheet" href="./assets/css/codeDisplay.css"/>
    <title>K-Scaffold | PUG</title>
  </head>
  <body>
    <header>
      <h1>The K-Scaffold Framework</h1><span class="subhead">PUG, HTML, and Javascript</span>
    </header>
    <nav>
      <ul>
        <li><a href="./index.html?v=1.1">General Info</a></li>
        <li><a href="./js.html?v=1.1">Sheetworker Documentation</a></li>
      </ul>
      <ul>
        <li><a href="#intro-header">Intro</a></li>
        <li><a href="#" id="doc-link">PUG Mixins & Functions</a></li>
        <li><a href="#contact-header">Contact & Feedback</a></li>
      </ul>
    </nav>
    <main id="doc-target">
      <section aria-labelledby="intro-header">
        <h2 id="intro-header">The PUG Library</h2>
        <div class="border"></div>
        <div class="content">
          <p>The K-Scaffold's PUG library provides a collection of frequently used elements and collections of elements in Roll20 sheet development. The library's mixins also provide a link to the sheetworker library via the trigger property that can be passed to many of these mixins. The sections below give the details on how the mixins can be used and what html is generated by them.</p>
          <h3>The Trigger Object</h3>
          <p>The trigger object is a K-Scaffold specific property that can be passed to any mixin that creates a Roll20 attribute element (e.g. <a href="#input">input</a> or <a href="#span">span</a>). The trigger object creates a link between the attribute, and any attributes that are affected by it or any functions that should be called when the attribute is changed. This looks like:</p>
          <h4>pug</h4>
          <pre class="prettyprint"><code class="language-jade">+number({name:'strength',value:10,trigger:{affects:['strength_mod']}})
+number({name:'strength mod',value:0,readonly:'',trigger:{calculation:'calcStrength'}})</code></pre>
          <h4>html</h4>
          <pre class="prettyprint"><code class="language-html">&lt;number type=&quot;number&quot; name=&quot;attr_strength&quot; value=&quot;10&quot;&gt;
&lt;number type=&quot;number&quot; name=&quot;attr_strength_mod&quot; value=&quot;0&quot;&gt;</code></pre>
          <h4>sheetworker</h4>
          <pre class="prettyprint"><code class="language-js">//This function will be called whenever strength_mod is affected by another attribute. It will return the calculated value, and the K-Scaffold sheetworker framework will set the attribute to that value.
const calcStrength = function({attributes}){
  return Math.floor((attributes.strength - 10) / 2);
}
//Register the function to the K-Scaffold sheetworker framework so that it can be called by the scaffold's listeners.
k.registerFuncs({calcStrength});</code></pre>
          <p>Note that when using the K-Scaffold to drive the event handling, you only need to write your actual calculation or logic functions, not any of the sheetworker event handling. Functions called by the K-Scaffold's trigger handling should be written using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">object descructuring pattern</a> and can have any (or all) argument of:</p>
          <ul style="display:flex;flex-direction:column;">
            <li>
              <pre class="snippet"><code>attributes</code></pre>
            </li>
            <li>
              <pre class="snippet"><code>trigger</code></pre>
            </li>
            <li>
              <pre class="snippet"><code>casc</code></pre>
            </li>
          </ul>
          <p>Because this uses the destructuring pattern, these attribute names must be named this, but can be in any order in the function declaration.</p>
        </div>
      </section>
      <span>Each starts here</span>
        <section>
          <div>
            <h3 class="no-capital" id="adaptiveTextarea">adaptiveTextarea</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates an html construction for creating a [content-scaled](https://wiki.roll20.net/CSS_Wizardry#Content-scaled_Inputs) textarea. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>textObj</span>
                <span>object</span>
                <p>The object describing the textarea as per the {@link textarea} mixin.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +adaptiveTextarea({name:&#x27;character description&#x27;})
        
        //Appending the class directly to the mixin
        +adaptiveTextarea({name:&#x27;character description&#x27;}).custom-class</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;adaptive adaptive--text&quot;&gt;&lt;span class&#x3D;&quot;adaptive--text__span&quot; name&#x3D;&quot;attr_character_description&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/span&gt;&lt;textarea class&#x3D;&quot;adaptive--text__textarea&quot; name&#x3D;&quot;attr_character_description&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;!--Appending the class directly to the mixin--&gt;&lt;div class&#x3D;&quot;adaptive adaptive--text custom-class&quot;&gt;&lt;span class&#x3D;&quot;adaptive--text__span&quot; name&#x3D;&quot;attr_character_description&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/span&gt;&lt;textarea class&#x3D;&quot;adaptive--text__textarea&quot; name&#x3D;&quot;attr_character_description&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="adaptiveInput">adaptiveInput</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates an html construction for creating a [content-scaled](https://wiki.roll20.net/CSS_Wizardry#Content-scaled_Inputs) input. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>inputObj</span>
                <span>object</span>
                <p>The object describing the input as per the {@link input} mixin. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +adaptiveInput({name:&#x27;character description&#x27;,type:&#x27;text&#x27;})
        
        //Appending class directly to the mixin
        +adaptiveInput({name:&#x27;character description&#x27;,type:&#x27;text&#x27;}).custom-class</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;adaptive adaptive--input&quot;&gt;&lt;span class&#x3D;&quot;adaptive--input__span&quot; name&#x3D;&quot;attr_character_description&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/span&gt;&lt;input class&#x3D;&quot;adaptive--input__input&quot; name&#x3D;&quot;attr_character_description&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{character_description}&quot;/&gt;&lt;/div&gt;&lt;!--Appending class directly to the mixin--&gt;&lt;div class&#x3D;&quot;adaptive adaptive--input custom-class&quot;&gt;&lt;span class&#x3D;&quot;adaptive--input__span&quot; name&#x3D;&quot;attr_character_description&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/span&gt;&lt;input class&#x3D;&quot;adaptive--input__input&quot; name&#x3D;&quot;attr_character_description&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{character_description}&quot;/&gt;&lt;/div&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="img">img</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A mixin to create a sheet image element. Particularly useful when using the image attribute syntax.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +img({name:&#x27;my image&#x27;,class:&#x27;some-class&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;img class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_image&quot; data-i18n-alt&#x3D;&quot;my image&quot; title&#x3D;&quot;@{my_image}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="span">span</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a span element and formats the name of the span for compatibility with the Roll20 attribute system.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>attrObj</span>
                <span>object</span>
                <p>The object describing the span itself.</p>
                <span>block</span>
                <span>block</span>
                <p>What is contained within the span</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +span({name:&#x27;attribute backed span&#x27;,trigger:{calculation:&#x27;calculateAttribute&#x27;}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;span name&#x3D;&quot;attr_attribute_backed_span&quot; title&#x3D;&quot;@{attribute_backed_span}&quot;&gt;&lt;/span&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="div">div</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a div element and will properly format the name attribute of the div if it is provided</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>divObj</span>
                <span>object</span>
                <p>The object describing the div</p>
                <span>block</span>
                <span>block</span>
                <p>The contents of the div</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +div({name:&#x27;background image&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div name&#x3D;&quot;attr_background_image&quot; title&#x3D;&quot;@{background_image}&quot;&gt;&lt;/div&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="button">button</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a button element. Valid types are &#x60;roll&#x60; or &#x60;action&#x60;. If a type is not specified in the object argument, a roll button is created. If an action button is created, spaces in the name are replaced with dashes instead of underscores.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>buttonObj</span>
                <span>object</span>
                <p>The object describing the button</p>
                <span>block</span>
                <span>block</span>
                <p>The contents of the button element</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        //A basic roll button
        +button({name:&#x27;my button&#x27;,value:&#x27;/r 3d10&#x27;})
        //An action button
        +button({name:&#x27;my button&#x27;,type:&#x27;action&#x27;,&#x27;data-i18n&#x27;:&#x27;action button&#x27;,trigger:{triggeredFuncs:[&#x27;doSomethingOnClick&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;!--A basic roll button--&gt;&lt;button name&#x3D;&quot;roll_my_button&quot; value&#x3D;&quot;/r 3d10&quot; title&#x3D;&quot;%{my_button}&quot; type&#x3D;&quot;roll&quot;&gt;&lt;/button&gt;&lt;!--An action button--&gt;&lt;button name&#x3D;&quot;act_my_button&quot; type&#x3D;&quot;action&quot; data-i18n&#x3D;&quot;action button&quot; title&#x3D;&quot;%{my_button}&quot;&gt;&lt;/button&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="action">action</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Alias for {@link button} that creates a button element with a type of &#x60;action&#x60;. Spaces in the name are replaced with dashes instead of underscores.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +action({name:&#x27;my button&#x27;,&#x27;data-i18n&#x27;:&#x27;action button&#x27;,trigger:{triggeredFuncs:[&#x27;doSomethingOnClick&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;button name&#x3D;&quot;act_my-button&quot; data-i18n&#x3D;&quot;action button&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{my-button}&quot;&gt;&lt;/button&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="navButton">navButton</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Alias for {@link button} that creates a button element with a type of &#x60;action&#x60; for use in nav buttons. Spaces in the name are replaced with dashes instead of underscores. The name is prefixed with &#x60;nav_&#x60;. A {@link trigger} object should be passed</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +navButton({name:&#x27;my button&#x27;,&#x27;data-i18n&#x27;:&#x27;action button&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;button name&#x3D;&quot;act_nav-my-button&quot; data-i18n&#x3D;&quot;action button&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{nav-my-button}&quot;&gt;&lt;/button&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="roller">roller</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a multi element construction made of a hidden input, a roll button, and a hidden action button. On sheet load, or character sheet name change, the hidden input is updated with an ability call to the action button. The roll button refers to the hidden input as its value. This allows for an action button to be used to call custom roll parsing (or other sheet functionality) while retaining the ability to drag the button to the macro bar. Uses the same arguments as {@link button}. A trigger should be passed, and will be associated with the action button&#x27;s name.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +roller({name:&#x27;my button&#x27;,&#x27;data-i18n&#x27;:&#x27;action button&#x27;,trigger:{triggeredFuncs:[&#x27;doSomethingOnClick&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;button class&#x3D;&quot;roller&quot; name&#x3D;&quot;roll_my_button&quot; data-i18n&#x3D;&quot;action button&quot; value&#x3D;&quot;@{my_button_action}&quot; title&#x3D;&quot;%{my_button}&quot; type&#x3D;&quot;roll&quot;&gt;&lt;/button&gt;&lt;button name&#x3D;&quot;act_my-button-action&quot; hidden&#x3D;&quot;&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{my-button-action}&quot;&gt;&lt;/button&gt;&lt;input name&#x3D;&quot;attr_my_button_action&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{my_button_action}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="compendiumAttributes">compendiumAttributes</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a set of compendium drop target attributes. Defaults to creating target attributes for the &#x60;Name&#x60; and &#x60;data&#x60; compendium attributes.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>prefix</span>
                <span>string</span>
                <p>A prefix to attach to the default attribute names.</p>
                <span>lookupAttributes</span>
                <span>array</span>
                <p>An array of the lookup attributes to create targets for. The target attributes are named based on the compendium attribute they are for.</p>
                <span>triggerAccept</span>
                <span>string</span>
                <p>The compendium attribute that should trigger the sheetworkers to handle the compendium drop.</p>
                <span>trigger</span>
                <span>object</span>
                <p>The trigger object.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        //Using just defaults
        +compendiumAttributes({})
        
        //Specifying a prefix
        +compendiumAttributes({prefix:&#x27;prefix&#x27;})
        
        //Specifying lookupAttributes and a prefix
        +compendiumAttributes({lookupAttributes:[&#x27;Name&#x27;,&#x27;data&#x27;,&#x27;Category&#x27;],prefix:&#x27;prefix&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;!--Using just defaults--&gt;&lt;input name&#x3D;&quot;attr_drop_name&quot; accept&#x3D;&quot;Name&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{drop_name}&quot;/&gt;&lt;input name&#x3D;&quot;attr_drop_data&quot; accept&#x3D;&quot;data&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{drop_data}&quot;/&gt;&lt;!--Specifying a prefix--&gt;&lt;input name&#x3D;&quot;attr_prefix_drop_name&quot; accept&#x3D;&quot;Name&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{prefix_drop_name}&quot;/&gt;&lt;input name&#x3D;&quot;attr_prefix_drop_data&quot; accept&#x3D;&quot;data&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{prefix_drop_data}&quot;/&gt;&lt;!--Specifying lookupAttributes and a prefix--&gt;&lt;input name&#x3D;&quot;attr_prefix_drop_name&quot; accept&#x3D;&quot;Name&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{prefix_drop_name}&quot;/&gt;&lt;input name&#x3D;&quot;attr_prefix_drop_data&quot; accept&#x3D;&quot;data&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{prefix_drop_data}&quot;/&gt;&lt;input name&#x3D;&quot;attr_prefix_drop_category&quot; accept&#x3D;&quot;Category&quot; value&#x3D;&quot;&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{prefix_drop_category}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="fillLeft">fillLeft</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A mixin that creates an html construction ready to be styled for use as a [fill-to-left section](https://wiki.roll20.net/CSS_Wizardry#Fill_Radio_Buttons_to_the_Left).</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>radioObj</span>
                <span>object</span>
                <p>The object containing the details of the radio input to create. Similar to the {@link radio}, but the value property passed is used as the default checked value.</p>
                <span>divObj</span>
                <span>object</span>
                <p>Optional object containing any details of the div to be applied such as class, id, or other properties. Class and ID can also be supplied by attaching them to the mixin invocation just like with a regular div.</p>
                <span>valueArray</span>
                <span>array</span>
                <p>Array containing the values to be used for the fill to left construction. These should be in the order that they should be displayed left to right.</p>
                <span>noClear</span>
                <span>boolean</span>
                <p>Optional argument that tells the mixin whether or not to apply the &#x60;fill-left__radio--clearer&#x60; class to the first radio button value. If falsy (or not passed), the class is applied. If truthy, the class is not applied.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +fillLeft({
          radioObj:{name:&#x27;my radio&#x27;},
          divObj:{class:&#x27;some-custom-class&#x27;},
          valueArray:[1,2,3,4,5]
        })</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;fill-left some-custom-class&quot;&gt;&lt;input class&#x3D;&quot;fill-left__radio&quot; name&#x3D;&quot;attr_my_radio&quot; value&#x3D;&quot;0&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{my_radio}&quot;/&gt;&lt;input class&#x3D;&quot;fill-left__radio&quot; name&#x3D;&quot;attr_my_radio&quot; value&#x3D;&quot;1&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{my_radio}&quot;/&gt;&lt;input class&#x3D;&quot;fill-left__radio&quot; name&#x3D;&quot;attr_my_radio&quot; value&#x3D;&quot;2&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{my_radio}&quot;/&gt;&lt;input class&#x3D;&quot;fill-left__radio&quot; name&#x3D;&quot;attr_my_radio&quot; value&#x3D;&quot;3&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{my_radio}&quot;/&gt;&lt;input class&#x3D;&quot;fill-left__radio&quot; name&#x3D;&quot;attr_my_radio&quot; value&#x3D;&quot;4&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{my_radio}&quot;/&gt;&lt;input class&#x3D;&quot;fill-left__radio&quot; name&#x3D;&quot;attr_my_radio&quot; value&#x3D;&quot;5&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{my_radio}&quot;/&gt;&lt;/div&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="input">input</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A generic mixin to create an input. The mixin will replace spaces in the attribute name with underscores and will add a title property if one isn&#x27;t supplied that will inform the user what the attribute call for the attribute is.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>inputObj</span>
                <span>object</span>
                <p>An object describing the properties of the input just like they would be in a PUG or HTML element declaration, but in JS Object syntax. May also include a trigger property</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +input({name:&#x27;my attribute&#x27;,type:&#x27;text&#x27;,class:&#x27;some-class&#x27;,trigger:{affects:[&#x27;other_attribute&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;input class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_attribute&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{my_attribute}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="text">text</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>An alias for {@link input} that specifies the input type as text. See {@link input} for arguments.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +text({name:&#x27;my attribute&#x27;,class:&#x27;some-class&#x27;,trigger:{affects:[&#x27;other_attribute&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;input class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_attribute&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{my_attribute}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="collapse">collapse</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Alias for {@link checkbox} that creates a checkbox for us in collapse/expanding a section. Sets the checkbox to unchecked with a checked value of &#x60;1&#x60; and a class of &#x60;collapse&#x60;. Additional classes/ids can be applied by applying them inline to the mixin call.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>name</span>
                <span>string</span>
                <p>The name to use for the collapse element. Defaults to &#x60;collapse&#x60;</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +collapse()</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;input class&#x3D;&quot;collapse&quot; name&#x3D;&quot;attr_collapse&quot; value&#x3D;&quot;1&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{collapse}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="number">number</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Alias for {@link input} that makes a number input. See {@link input} for arguments.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +number({name:&#x27;my number&#x27;,class:&#x27;some-class&#x27;,trigger:{affects:[&#x27;other_attribute&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;input class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_number&quot; type&#x3D;&quot;number&quot; title&#x3D;&quot;@{my_number}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="range">range</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Alias for {@link input} that makes a range input. See {@link input} for arguments.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +range({name:&#x27;my range&#x27;,class:&#x27;some-class&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;input class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_range&quot; type&#x3D;&quot;range&quot; title&#x3D;&quot;@{my_range}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="hidden">hidden</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Alias for {@link input} that makes a hidden input. See {@link input} for arguments.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +hidden({name:&#x27;my hidden attribute&#x27;,class:&#x27;some-class&#x27;,trigger:{triggeredFuncs:[&#x27;someFunction&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;input class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_hidden_attribute&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{my_hidden_attribute}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="textarea">textarea</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A mixin to create K-scaffold compatible textareas.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>textObj</span>
                <span>object</span>
                <p>See {@link input} for information on valid properties of the textObj.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +textarea({name:&#x27;my textarea&#x27;,class:&#x27;some-class&#x27;,trigger:{affects:[&#x27;an_attribute&#x27;]}})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;textarea class&#x3D;&quot;some-class&quot; name&#x3D;&quot;attr_my_textarea&quot; title&#x3D;&quot;@{my_textarea}&quot;&gt;&lt;/textarea&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="select">select</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A mixin to create a select element. Uses K-scaffold global variables to control how {@link option} mixins within the select&#x27;s block behave.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>inputObj</span>
                <span>object</span>
                <p>The object describing the select</p>
                <span>block</span>
                <span>block</span>
                <p>The content within the select</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +select({name:&#x27;my select&#x27;})
          +option({value:&#x27;a value&#x27;,&#x27;data-i18n&#x27;:&#x27;a translation key&#x27;,trigger:{affects:[&#x27;some_attribute&#x27;]}})
          +option({value:&#x27;value 2&#x27;,&#x27;data-i18n&#x27;:&#x27;translation 2&#x27;})
          +option({value:&#x27;value 3&#x27;})
            |Some Text we include via the option&#x27;s block</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;select name&#x3D;&quot;attr_my_select&quot; title&#x3D;&quot;@{my_select}&quot;&gt;&lt;option value&#x3D;&quot;a value&quot; data-i18n&#x3D;&quot;a translation key&quot;&gt;&lt;/option&gt;&lt;option value&#x3D;&quot;value 2&quot; data-i18n&#x3D;&quot;translation 2&quot;&gt;&lt;/option&gt;&lt;option value&#x3D;&quot;value 3&quot;&gt;&lt;/option&gt;&lt;/select&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="fieldset">fieldset</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A mixin that creates a fieldset for the creation of a repeating section. The mixin prefixes the name with &#x60;repeating_&#x60; and replaces problem characters (e.g. spaces are replaced with dashes). Additionally, the auto-generated title properties from the K-scaffold\&#x27;s mixins will include the proper repeating section information.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>name</span>
                <span>string</span>
                <p>The name of the repeating section. Will be prefixed with &#x60;repeating_&#x60; and spaces will be replaced with dashes (&#x60;-&#x60;).</p>
                <span>trigger</span>
                <span>object</span>
                <p>Trigger that defines how to handle the removal of a row from the fieldset. &#x60;Optional&#x60;</p>
                <span>addClass</span>
                <span>string</span>
                <p>Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like &#x60;.bonus-class + fieldset + .repcontainer&#x60;.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        //A basic fieldset declaration with a trigger
        +fieldset({
          name:&#x27;fieldset&#x27;,
          trigger:{triggeredFuncs:[&#x27;doWhenRemoved&#x27;]}
        })
          +text({name:&#x27;name&#x27;})
        
        //A Fieldset with an added class
        +fieldset({
          name:&#x27;fieldset&#x27;,
          trigger:{triggeredFuncs:[&#x27;doWhenRemoved&#x27;]},
          addClass:&#x27;some-class&#x27;
        })
          +text({name:&#x27;name&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;!--A basic fieldset declaration with a trigger--&gt;&lt;fieldset class&#x3D;&quot;repeating_fieldset&quot;&gt;&lt;input name&#x3D;&quot;attr_name&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{repeating_fieldset_$X_name}&quot;/&gt;&lt;/fieldset&gt;&lt;!--A Fieldset with an added class--&gt;&lt;span class&#x3D;&quot;some-class&quot; hidden&#x3D;&quot;&quot;&gt;&lt;/span&gt;&lt;fieldset class&#x3D;&quot;repeating_fieldset&quot;&gt;&lt;input name&#x3D;&quot;attr_name&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{repeating_fieldset_$X_name}&quot;/&gt;&lt;/fieldset&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="inlineFieldset">inlineFieldset</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>An alias for {@link fieldset} that creates a fieldset with an added class that can be easily hooked into via CSS to style the fieldset for inline display.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>name</span>
                <span>string</span>
                <p>The name of the repeating section. Will be prefixed with &#x60;repeating_&#x60; and spaces will be replaced with dashes (&#x60;-&#x60;).</p>
                <span>trigger</span>
                <span>object</span>
                <p>Trigger that defines how to handle the removal of a row from the fieldset. &#x60;Optional&#x60;</p>
                <span>addClass</span>
                <span>string</span>
                <p>Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like &#x60;.bonus-class + fieldset + .repcontainer&#x60;.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +inlineFieldset({
          name:&#x27;fieldset&#x27;,
          trigger:{triggeredFuncs:[&#x27;doWhenRemoved&#x27;]},
          addClass:&#x27;some-class&#x27;
        })</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;span class&#x3D;&quot;some-class inline-fieldset&quot; hidden&#x3D;&quot;&quot;&gt;&lt;/span&gt;&lt;fieldset class&#x3D;&quot;repeating_fieldset&quot;&gt;&lt;input class&#x3D;&quot;display-control&quot; name&#x3D;&quot;attr_display_state&quot; value&#x3D;&quot;short-display&quot; hidden&#x3D;&quot;&quot; type&#x3D;&quot;radio&quot; title&#x3D;&quot;@{repeating_fieldset_$X_display_state}&quot;/&gt;&lt;div class&#x3D;&quot;inline-fieldset__summary display-target&quot;&gt;&lt;label class&#x3D;&quot;pointer&quot;&gt;&lt;input name&#x3D;&quot;attr_collapse&quot; value&#x3D;&quot;1&quot; hidden&#x3D;&quot;&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{repeating_fieldset_$X_collapse}&quot;/&gt;&lt;span class&#x3D;&quot;inline-fieldset__summary__text&quot; name&#x3D;&quot;attr_name&quot; title&#x3D;&quot;@{repeating_fieldset_$X_name}&quot;&gt;&lt;/span&gt;&lt;/label&gt;&lt;/div&gt;&lt;input class&#x3D;&quot;display-control&quot; name&#x3D;&quot;attr_display_state&quot; value&#x3D;&quot;display&quot; checked&#x3D;&quot;&quot; hidden&#x3D;&quot;&quot; type&#x3D;&quot;radio&quot; title&#x3D;&quot;@{repeating_fieldset_$X_display_state}&quot;/&gt;&lt;div class&#x3D;&quot;inline-fieldset__detail display-target&quot;&gt;&lt;input class&#x3D;&quot;collapse&quot; name&#x3D;&quot;attr_collapse&quot; value&#x3D;&quot;1&quot; type&#x3D;&quot;checkbox&quot; title&#x3D;&quot;@{repeating_fieldset_$X_collapse}&quot;/&gt;&lt;/div&gt;&lt;/fieldset&gt;&lt;button class&#x3D;&quot;repcontrol-button repcontrol-button--add repcontrol-button--inline&quot; name&#x3D;&quot;act_add-fieldset&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{add-fieldset}&quot;&gt;&lt;/button&gt;&lt;button class&#x3D;&quot;repcontrol-button repcontrol-button--edit repcontrol-button--inline&quot; name&#x3D;&quot;act_edit-fieldset&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{edit-fieldset}&quot;&gt;&lt;/button&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="button-label">button-label</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>A mixin to create a combined button and input that are within the same container. Similar to {@link input-label}, but does not use a label.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>inputObj</span>
                <span>object</span>
                <p>An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.</p>
                <span>buttonObj</span>
                <span>object</span>
                <p>An object describing the button to be paired with the input. This is the same object that you would pass to {@link button}.</p>
                <span>divObj</span>
                <span>object</span>
                <p>An object describing the container div. Similar to the first two objects, but will most likely only have a &#x60;class&#x60; property if it is passed at all.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +button-label({
          inputObj:{name:&#x27;strength&#x27;,type:&#x27;number&#x27;,class:&#x27;underlined&#x27;,value:10,trigger:{affects:[&#x27;athletics&#x27;]}},
          buttonObj:{name:&#x27;strength_roll&#x27;,type:&#x27;roll&#x27;,value:&#x27;/r 1d20+@{strength}&#x27;},
          divObj:{class:&#x27;strength&#x27;}
        })</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;input-label input-label--button strength&quot;&gt;&lt;button name&#x3D;&quot;roll_strength_roll&quot; type&#x3D;&quot;roll&quot; value&#x3D;&quot;/r 1d20+@{strength}&quot; title&#x3D;&quot;%{strength_roll}&quot;&gt;&lt;/button&gt;&lt;input class&#x3D;&quot;underlined input-label__input&quot; name&#x3D;&quot;attr_strength&quot; type&#x3D;&quot;number&quot; value&#x3D;&quot;10&quot; title&#x3D;&quot;@{strength}&quot;/&gt;&lt;/div&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="roller-label">roller-label</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Similar to the construction created by {@link button-label}, except that it creates a {@link roller} construction instead of just a straight button.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>inputObj</span>
                <span>object</span>
                <p>An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.</p>
                <span>buttonObj</span>
                <span>object</span>
                <p>An object describing the button to be paired with the input. This is the same object that you would pass to {@link button}.</p>
                <span>divObj</span>
                <span>object</span>
                <p>An object describing the container div. Similar to the first two objects, but will most likely only have a &#x60;class&#x60; property if it is passed at all.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +roller-label({
          inputObj:{name:&#x27;strength&#x27;,type:&#x27;number&#x27;,class:&#x27;underlined&#x27;,value:10,trigger:{affects:[&#x27;athletics&#x27;]}},
          buttonObj:{name:&#x27;strength_roll&#x27;,type:&#x27;roll&#x27;,value:&#x27;/r 1d20+@{strength}&#x27;},
          divObj:{class:&#x27;strength&#x27;}
        })</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;input-label input-label--button strength&quot;&gt;&lt;button class&#x3D;&quot;roller&quot; name&#x3D;&quot;roll_strength_roll&quot; type&#x3D;&quot;roll&quot; value&#x3D;&quot;@{strength_action}&quot; title&#x3D;&quot;%{strength_roll}&quot;&gt;&lt;/button&gt;&lt;input class&#x3D;&quot;underlined input-label__input&quot; name&#x3D;&quot;attr_strength&quot; type&#x3D;&quot;number&quot; value&#x3D;&quot;10&quot; title&#x3D;&quot;@{strength}&quot;/&gt;&lt;/div&gt;&lt;button name&#x3D;&quot;act_strength-action&quot; hidden&#x3D;&quot;&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{strength-action}&quot;&gt;&lt;/button&gt;&lt;input name&#x3D;&quot;attr_strength_action&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{strength_action}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="action-label">action-label</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Similar to the construction created by {@link button-label}, except that it specifcally creates an [action button](https://wiki.roll20.net/Button#Action_Button) as per {@link action}.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>inputObj</span>
                <span>object</span>
                <p>An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.</p>
                <span>buttonObj</span>
                <span>object</span>
                <p>An object describing the button to be paired with the input. This is the same object that you would pass to {@link button}.</p>
                <span>divObj</span>
                <span>object</span>
                <p>An object describing the container div. Similar to the first two objects, but will most likely only have a &#x60;class&#x60; property if it is passed at all.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +roller-label({
          inputObj:{name:&#x27;strength&#x27;,type:&#x27;number&#x27;,class:&#x27;underlined&#x27;,value:10,trigger:{affects:[&#x27;athletics&#x27;]}},
          buttonObj:{name:&#x27;strength_roll&#x27;,type:&#x27;roll&#x27;,value:&#x27;/r 1d20+@{strength}&#x27;},
          divObj:{class:&#x27;strength&#x27;}
        })</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;input-label input-label--button strength&quot;&gt;&lt;button class&#x3D;&quot;roller&quot; name&#x3D;&quot;roll_strength_roll&quot; type&#x3D;&quot;roll&quot; value&#x3D;&quot;@{strength_action}&quot; title&#x3D;&quot;%{strength_roll}&quot;&gt;&lt;/button&gt;&lt;input class&#x3D;&quot;underlined input-label__input&quot; name&#x3D;&quot;attr_strength&quot; type&#x3D;&quot;number&quot; value&#x3D;&quot;10&quot; title&#x3D;&quot;@{strength}&quot;/&gt;&lt;/div&gt;&lt;button name&#x3D;&quot;act_strength-action&quot; hidden&#x3D;&quot;&quot; type&#x3D;&quot;action&quot; title&#x3D;&quot;%{strength-action}&quot;&gt;&lt;/button&gt;&lt;input name&#x3D;&quot;attr_strength_action&quot; type&#x3D;&quot;hidden&quot; title&#x3D;&quot;@{strength_action}&quot;/&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="select-label">select-label</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Similar to the construction created by {@link input-label}, except that the input is replaced with a select.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>label</span>
                <span>string</span>
                <p>The translation key to use for the span. If not passed, then the spanObj must be passed with a translation key</p>
                <span>inputObj</span>
                <span>object</span>
                <p>An object describing the select to be paired with the button. This is the same object that you would pass to {@link select}.</p>
                <span>divObj</span>
                <span>object</span>
                <p>An object describing the container label. Similar to the inputObj, but will most likely only have a &#x60;class&#x60; property if it is passed at all.</p>
                <span>spanObj</span>
                <span>object</span>
                <p>An object describing the span to be paired with the input. This is the same object that you would pass to {@link span}.</p>
                <span>block</span>
                <span>block</span>
                <p>The mixin uses the pug block as the content of the select.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +select-label({
          label:&#x27;Whisper to GM&#x27;,
          inputObj:{name:&#x27;whisper&#x27;},
          divObj:{class:&#x27;div-class&#x27;},
          spanObj:{class:&#x27;span-class&#x27;}
        })
          +option({value:&#x27;&#x27;,&#x27;data-i18n&#x27;:&#x27;never&#x27;,selected:&#x27;&#x27;})
          +option({value:&#x27;/w gm &#x27;,&#x27;data-i18n&#x27;:&#x27;always&#x27;})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;label class&#x3D;&quot;input-label div-class&quot;&gt;&lt;span class&#x3D;&quot;span-class input-label__text&quot; data-i18n&#x3D;&quot;Whisper to GM&quot;&gt;&lt;/span&gt;&lt;select class&#x3D;&quot;input-label__input&quot; name&#x3D;&quot;attr_whisper&quot; title&#x3D;&quot;@{whisper}&quot;&gt;&lt;option value&#x3D;&quot;&quot; data-i18n&#x3D;&quot;never&quot; selected&#x3D;&quot;&quot;&gt;&lt;/option&gt;&lt;option value&#x3D;&quot;/w gm &quot; data-i18n&#x3D;&quot;always&quot;&gt;&lt;/option&gt;&lt;/select&gt;&lt;/label&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="input-label">input-label</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p></p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>label</span>
                <span>string</span>
                <p>The translation key to use for the span. If not passed, then the spanObj must be passed with a translation key</p>
                <span>inputObj</span>
                <span>object</span>
                <p>An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.</p>
                <span>divObj</span>
                <span>object</span>
                <p>An object describing the container label. Similar to the inputObj, but will most likely only have a &#x60;class&#x60; property if it is passed at all.</p>
                <span>spanObj</span>
                <span>object</span>
                <p>An object describing the span to be paired with the input. This is the same object that you would pass to {@link span}.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +input-label({
          label:&#x27;strength&#x27;,
          inputObj:{name:&#x27;strength&#x27;,type:&#x27;number&#x27;},
          divObj:{class:&#x27;div-class&#x27;},
          spanObj:{class:&#x27;span-class&#x27;}
        })</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;label class&#x3D;&quot;input-label div-class&quot;&gt;&lt;span class&#x3D;&quot;span-class input-label__text&quot; data-i18n&#x3D;&quot;strength&quot;&gt;&lt;/span&gt;&lt;input class&#x3D;&quot;input-label__input&quot; name&#x3D;&quot;attr_strength&quot; type&#x3D;&quot;number&quot; title&#x3D;&quot;@{strength}&quot;/&gt;&lt;/label&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="headedTextarea">headedTextarea</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a construction for pairing a header with a textarea. Currently is locked to creating an &#x60;h3&#x60;.  This mixin also accepts classes and IDs appended directly to it (see the second example)</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>textObj</span>
                <span>object</span>
                <p>The object describing the textarea as per {@link textarea}</p>
                <span>header</span>
                <span>string</span>
                <p>The &#x60;data-i18n&#x60; translation key to use for the header</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +headedTextarea({textObj:{name:&#x27;character description&#x27;,&#x27;data-i18n-placeholder&#x27;:&#x27;The description of your character&#x27;},header:&#x27;description&#x27;})
        //With class appended to the mixin itself
        +headedTextarea({textObj:{name:&#x27;character description&#x27;,&#x27;data-i18n-placeholder&#x27;:&#x27;The description of your character&#x27;},header:&#x27;description&#x27;}).character-description</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;div class&#x3D;&quot;headed-textarea&quot;&gt;&lt;h3 class&#x3D;&quot;headed-textarea__header&quot; data-i18n&#x3D;&quot;description&quot;&gt;&lt;/h3&gt;&lt;textarea class&#x3D;&quot;headed-textarea__textarea&quot; name&#x3D;&quot;attr_character_description&quot; data-i18n-placeholder&#x3D;&quot;The description of your character&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;!--With class appended to the mixin itself--&gt;&lt;div class&#x3D;&quot;headed-textarea character-description&quot;&gt;&lt;h3 class&#x3D;&quot;headed-textarea__header&quot; data-i18n&#x3D;&quot;description&quot;&gt;&lt;/h3&gt;&lt;textarea class&#x3D;&quot;headed-textarea__textarea&quot; name&#x3D;&quot;attr_character_description&quot; data-i18n-placeholder&#x3D;&quot;The description of your character&quot; title&#x3D;&quot;@{character_description}&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="SetSystemPrefix">SetSystemPrefix</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Updates the systemPrefix K-&quot;scaffold global variable so that any attributes created after this point will be prepended with the prefix. By default attributes in repeating sections are not prepended; instead the repeating section name is prefixed. Returns the previous prefix.&quot;</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>val</span>
                <span>string</span>
                <p>The value to set the prefix to. If not a string or falsy, will reset the prefix to an empty string.</p>
                <span>normalRepeating</span>
                <span>boolean</span>
                <p>Whether the prefix should be applied to repeating section names (default), or to the attribute name itself in repeating sections.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        // Non repeating attributes
        setSystemPrefix(&#x27;npc&#x27;)
        +number({name:&#x27;athletics&#x27;,value:0})
        
        // pass it a falsy value to unset it
        setSystemPrefix(false)
        +number({name:&#x27;athletics&#x27;,value:0})
        
        // Repeating attributes
        setSystemPrefix(&#x27;npc&#x27;)
        +fieldset({name:&#x27;skill&#x27;})
          +number({name:&#x27;score&#x27;,value:0})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;!-- Non repeating attributes--&gt;&lt;setSystemPrefix npc&#x3D;&quot;npc&quot;&gt;&lt;/setSystemPrefix&gt;&lt;input name&#x3D;&quot;attr_athletics&quot; value&#x3D;&quot;0&quot; type&#x3D;&quot;number&quot; title&#x3D;&quot;@{athletics}&quot;/&gt;&lt;!-- pass it a falsy value to unset it--&gt;&lt;setSystemPrefix false&#x3D;&quot;false&quot;&gt;&lt;/setSystemPrefix&gt;&lt;input name&#x3D;&quot;attr_athletics&quot; value&#x3D;&quot;0&quot; type&#x3D;&quot;number&quot; title&#x3D;&quot;@{athletics}&quot;/&gt;&lt;!-- Repeating attributes--&gt;&lt;setSystemPrefix npc&#x3D;&quot;npc&quot;&gt;&lt;/setSystemPrefix&gt;&lt;fieldset class&#x3D;&quot;repeating_skill&quot;&gt;&lt;input name&#x3D;&quot;attr_score&quot; value&#x3D;&quot;0&quot; type&#x3D;&quot;number&quot; title&#x3D;&quot;@{repeating_skill_$X_score}&quot;/&gt;&lt;/fieldset&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="attrTitle">attrTitle</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Converts an attribute name into an attribute call for that attribute. Converts &#x60;_max&#x60; attribute names to the proper attribute call syntax for &#x60;_max&#x60; attributes (see second example). If called from inside the block of a {@link fieldset} mixin, will also add the appropriate information for calling a repeating attribute.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>attrName</span>
                <span>string</span>
                <p>The attribute name to create an attribute call for.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        //Basic attribute name
        +input({name:&#x27;hidden name&#x27;,type:&#x27;text&#x27;,title:attrTitle(&#x27;user accessible name&#x27;)})
        
        //Max attribute name
        +input({name:&#x27;hidden max&#x27;,type:&#x27;number&#x27;,title:attrTitle(&#x27;user accessible max&#x27;)})
        
        //fieldset attrTitle
        +fieldset({name:&#x27;equipment&#x27;})
          +input({name:&#x27;name&#x27;,type:&#x27;text&#x27;,title:attrTitle(&#x27;user accessible name&#x27;)})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;!--Basic attribute name--&gt;&lt;input name&#x3D;&quot;attr_hidden_name&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{user_accessible_name}&quot;/&gt;&lt;!--Max attribute name--&gt;&lt;input name&#x3D;&quot;attr_hidden_max&quot; type&#x3D;&quot;number&quot; title&#x3D;&quot;@{user_accessible|max}&quot;/&gt;&lt;!--fieldset attrTitle--&gt;&lt;fieldset class&#x3D;&quot;repeating_equipment&quot;&gt;&lt;input name&#x3D;&quot;attr_name&quot; type&#x3D;&quot;text&quot; title&#x3D;&quot;@{repeating_equipment_$X_user_accessible_name}&quot;/&gt;&lt;/fieldset&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="buttonTitle">buttonTitle</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Converts an ability name into an ability call for that attribute. If called from inside the block of a {@link fieldset} mixin, will also add the appropriate information for calling a repeating attribute.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
                <span>abilityName</span>
                <span>string</span>
                <p>The ability name to create a call for.</p>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        //Basic button title
        +button({name:&#x27;hidden button&#x27;,type:&#x27;text&#x27;,title:buttonTitle(&#x27;user accessible name&#x27;)})
        
        //fieldset button title
        +fieldset({name:&#x27;equipment&#x27;})
          +button({name:&#x27;button&#x27;,type:&#x27;text&#x27;,title:buttonTitle(&#x27;user accessible name&#x27;)})</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;!--Basic button title--&gt;&lt;button name&#x3D;&quot;roll_hidden_button&quot; type&#x3D;&quot;roll&quot; title&#x3D;&quot;%{user_accessible_name}&quot;&gt;&lt;/button&gt;&lt;!--fieldset button title--&gt;&lt;fieldset class&#x3D;&quot;repeating_equipment&quot;&gt;&lt;button name&#x3D;&quot;roll_button&quot; type&#x3D;&quot;roll&quot; title&#x3D;&quot;%{repeating_equipment_$X_user_accessible_name}&quot;&gt;&lt;/button&gt;&lt;/fieldset&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="script">script</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Creates a generic [Roll20 script block](https://wiki.roll20.net/Building_Character_Sheets#JavaScript_2) for use with the sheetworker system.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +script</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;script type&#x3D;&quot;text/worker&quot;&gt;&lt;/script&gt;</code></pre>
          </div>
        </section>        <section>
          <div>
            <h3 class="no-capital" id="kscript">kscript</h3>
          </div>
          <div class="border"></div>
          <div class="content">
            <p>Similar to {@link script}, but includes the K-scaffold\&#x27;s javascript function library.</p>
            <div class="arguments-container">
              <h4>arguments</h4>
              <h5>name</h5>
              <h5>type</h5>
              <h5>description</h5>
            </div>
              <h4>pug</h4>
              <pre class="prettyprint" style=""><code class="language-jade">include ../_k.pug
        +kscript</code></pre>
              <h4>html</h4>
              <pre class="prettyprint" style=""><code class="language-html">&lt;script type&#x3D;&quot;text/worker&quot;&gt;const k &#x3D; (function(){
        const kFuncs &#x3D; {};
        const cascades &#x3D; {&quot;attr_character_name&quot;:{&quot;name&quot;:&quot;character_name&quot;,&quot;type&quot;:&quot;text&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;affects&quot;:[],&quot;triggeredFuncs&quot;:[&quot;setActionCalls&quot;],&quot;listenerFunc&quot;:&quot;accessSheet&quot;,&quot;listener&quot;:&quot;change:character_name&quot;}};
        
        kFuncs.cascades &#x3D; cascades;
        const repeatingSectionDetails &#x3D; [];
        
        kFuncs.repeatingSectionDetails &#x3D; repeatingSectionDetails;
        /**
         * This stores the name of your sheet for use in the logging functions {@link log} and {@link debug}. Accessible by &#x60;k.sheetName&#x60;
         * @var
         * @type {string}
         */
        let sheetName &#x3D; &#x27;kScaffold Powered Sheet&#x27;;
        kFuncs.sheetName &#x3D; sheetName;
        /**
        	* This stores the version of your sheet for use in the logging functions{@link log} and {@link debug}. It is also stored in the sheet_version attribute on your character sheet. Accessible via &#x60;k.version&#x60;
        	* @var
        	* @type {number}
        	*/
        let version &#x3D; 0;
        kFuncs.version &#x3D; version;
        /**
        	* A boolean flag that tells the script whether to enable or disable {@link debug} calls. If the version of the sheet is &#x60;0&#x60;, or an attribute named &#x60;debug_mode&#x60; is found on opening this is set to true for your entire session. Otherwise, it remains false.
        	* @var
        	* @type {boolean}
        	*/
        let debugMode &#x3D; false;
        kFuncs.debugMode &#x3D; debugMode;
        const funcs &#x3D; {};
        kFuncs.funcs &#x3D; funcs;
        const updateHandlers &#x3D; {};
        const openHandlers &#x3D; {};
        const initialSetups &#x3D; {};
        const allHandlers &#x3D; {};
        const addFuncs &#x3D; {};
        
        const kscaffoldJSVersion &#x3D; &#x27;0.0.4&#x27;;
        const kscaffoldPUGVersion &#x3D; &#x27;0.0.4&#x27;;
        /*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
        /*jshint -W014,-W084,-W030,-W033*/
        /**
         * Replaces problem characters to use a string as a regex
         * @param {string} text - The text to replace characters in
         * @returns {string}
         * @example
         * const textForRegex &#x3D; k.sanitizeForRegex(&#x27;.some thing[with characters]&#x27;);
         * console.log(textForRegex);// &#x3D;&gt; &quot;\.some thing\[with characters\]&quot;
         */
        const sanitizeForRegex &#x3D; function(text){
          return text.replace(/\.|\||\(|\)|\[|\]|\-|\+|\?|\/|\{|\}|\^|\$|\*/g,&#x27;\\$&amp;&#x27;);
        };
        kFuncs.sanitizeForRegex &#x3D; sanitizeForRegex;
        
        /**
         * Converts a value to a number, it\&#x27;s default value, or &#x60;0&#x60; if no default value passed.
         * @param {string|number} val - Value to convert to a number
         * @param {number} def - The default value, uses 0 if not passed
         * @returns {number|undefined}
         * @example
         * const num &#x3D; k.value(&#x27;100&#x27;);
         * console.log(num);// &#x3D;&gt; 100
         */
        const value &#x3D; function(val,def){
          return (+val||def||0);
        };
        kFuncs.value &#x3D; value;
        
        /**
         * Extracts the section (e.g. &#x60;repeating_equipment&#x60;), rowID (e.g &#x60;-;lkj098J:LKj&#x60;), and field name (e.g. &#x60;bulk&#x60;) from a repeating attribute name.
         * @param {string} string - The string to parse
         * @returns {array} - Array of matches. Index 0: the section name, e.g. repeating_equipment | Index 1:the row ID | index 2: The name of the attribute
         * @returns {string[]}
         * @example
         * //Extract info from a full repeating name
         * const [section,rowID,attrName] &#x3D; k.parseRepeatName(&#x27;repeating_equipment_-8908asdflkjZlkj23_name&#x27;);
         * console.log(section);// &#x3D;&gt; &quot;repeating_equipment&quot;
         * console.log(rowID);// &#x3D;&gt; &quot;-8908asdflkjZlkj23&quot;
         * console.log(attrName);// &#x3D;&gt; &quot;name&quot;
         * 
         * //Extract info from just a row name
         * const [section,rowID,attrName] &#x3D; k.parseRepeatName(&#x27;repeating_equipment_-8908asdflkjZlkj23&#x27;);
         * console.log(section);// &#x3D;&gt; &quot;repeating_equipment&quot;
         * console.log(rowID);// &#x3D;&gt; &quot;-8908asdflkjZlkj23&quot;
         * console.log(attrName);// &#x3D;&gt; undefined
         */
        const parseRepeatName &#x3D; function(string){
          let match &#x3D; string.match(/(repeating_[^_]+)_([^_]+)(?:_(.+))?/);
          match.shift();
          return match;
        };
        kFuncs.parseRepeatName &#x3D; parseRepeatName;
        
        /**
         * Parses out the components of a trigger name similar to [parseRepeatName](#parserepeatname). Aliases: parseClickTrigger.
         * 
         * Aliases: &#x60;k.parseClickTrigger&#x60;
         * @param {string} string The triggerName property of the
         * @returns {array} - For a repeating button named &#x60;repeating_equipment_-LKJhpoi98;lj_roll&#x60;, the array will be &#x60;[&#x27;repeating_equipment&#x27;,&#x27;-LKJhpoi98;lj&#x27;,&#x27;roll&#x27;]&#x60;. For a non repeating button named &#x60;roll&#x60;, the array will be &#x60;[undefined,undefined,&#x27;roll&#x27;]&#x60;
         * @returns {string[]}
         * @example
         * //Parse a non repeating trigger
         * const [section,rowID,attrName] &#x3D; k.parseTriggerName(&#x27;clicked:some-button&#x27;);
         * console.log(section);// &#x3D;&gt; undefined
         * console.log(rowID);// &#x3D;&gt; undefined
         * console.log(attrName);// &#x3D;&gt; &quot;some-button&quot;
         * 
         * //Parse a repeating trigger
         * const [section,rowID,attrName] &#x3D; k.parseTriggerName(&#x27;clicked:repeating_attack_-234lkjpd8fu8usadf_some-button&#x27;);
         * console.log(section);// &#x3D;&gt; &quot;repeating_attack&quot;
         * console.log(rowID);// &#x3D;&gt; &quot;-234lkjpd8fu8usadf&quot;
         * console.log(attrName);// &#x3D;&gt; &quot;some-button&quot;
         * 
         * //Parse a repeating name
         * const [section,rowID,attrName] &#x3D; k.parseTriggerName(&#x27;repeating_attack_-234lkjpd8fu8usadf_some-button&#x27;);
         * console.log(section);// &#x3D;&gt; &quot;repeating_attack&quot;
         * console.log(rowID);// &#x3D;&gt; &quot;-234lkjpd8fu8usadf&quot;
         * console.log(attrName);// &#x3D;&gt; &quot;some-button&quot;
         */
        const parseTriggerName &#x3D; function(string){
          let match &#x3D; string.replace(/^clicked:/,&#x27;&#x27;).match(/(?:(repeating_[^_]+)_([^_]+)_)?(.+)/);
          match.shift();
          return match;
        };
        kFuncs.parseTriggerName &#x3D; parseTriggerName;
        const parseClickTrigger &#x3D; parseTriggerName;
        kFuncs.parseClickTrigger &#x3D; parseClickTrigger;
        
        /**
         * Parses out the attribute name from the htmlattribute name.
         * @param {string} string - The triggerName property of the [event](https://wiki.roll20.net/Sheet_Worker_Scripts#eventInfo_Object).
         * @returns {string}
         * @example
         * //Parse a name
         * const attrName &#x3D; k.parseHtmlName(&#x27;attr_attribute_1&#x27;);
         * console.log(attrName);// &#x3D;&gt; &quot;attribute_1&quot;
         */
        const parseHTMLName &#x3D; function(string){
          let match &#x3D; string.match(/(?:attr|act|roll)_(.+)/);
          match.shift();
          return match[0];
        };
        kFuncs.parseHTMLName &#x3D; parseHTMLName;
        
        /**
         * Capitalize each word in a string
         * @param {string} string - The string to capitalize
         * @returns {string}
         * @example
         * const capitalized &#x3D; k.capitalize(&#x27;a word&#x27;);
         * console.log(capitalized);// &#x3D;&gt; &quot;A Word&quot;
         */
        const capitalize &#x3D; function(string){
          return string.replace(/(?:^|\s+|\/)[a-z]/ig,(letter)&#x3D;&gt;letter.toUpperCase());
        };
        kFuncs.capitalize &#x3D; capitalize;
        
        /**
         * Extracts a roll query result for use in later functions. Must be awaited as per [startRoll documentation](https://wiki.roll20.net/Sheet_Worker_Scripts#Roll_Parsing.28NEW.29). Stolen from [Oosh\&#x27;s Adventures with Startroll thread](https://app.roll20.net/forum/post/10346883/adventures-with-startroll).
         * @param {string} query - The query should be just the text as the &#x60;?{&#x60; and &#x60;}&#x60; at the start/end of the query are added by the function.
         * @returns {Promise} - Resolves to the selected value from the roll query
         * @example
         * const rollFunction &#x3D; async function(){
         *  //Get the result of a choose from list query
         *  const queryResult &#x3D; await extractQueryResult(&#x27;Prompt Text Here|Option 1|Option 2&#x27;);
         *  console.log(queryResult);//&#x3D;&gt; &quot;Option 1&quot; or &quot;Option 2&quot; depending on what the user selects
         * 
         *  //Get free from input from the user
         *  const freeResult &#x3D; await extractQueryResult(&#x27;Prompt Text Here&#x27;);
         *  consoel.log(freeResult);// &#x3D;&gt; Whatever the user entered
         * }
         */
        const extractQueryResult &#x3D; async function(query){
        	debug(&#x27;entering extractQueryResult&#x27;);
        	let queryRoll &#x3D; await startRoll(&#x60;!{{query&#x3D;[[0[response&#x3D;?{${query}}]]]}}&#x60;);
        	finishRoll(queryRoll.rollId);
        	return queryRoll.results.query.expression.replace(/^.+?response&#x3D;|\]$/g,&#x27;&#x27;);
        };
        kFuncs.extractQueryResult &#x3D; extractQueryResult;
        
        /**
         * Simulates a query for ensuring that async/await works correctly in the sheetworker environment when doing conditional startRolls. E.g. if you have an if/else and only one of the conditions results in &#x60;startRoll&#x60; being called (and thus an &#x60;await&#x60;), the sheetworker environment would normally crash. Awaiting this in the condition that does not actually need to call &#x60;startRoll&#x60; will keep the environment in sync.
         * @param {string|number} [value] - The value to return. Optional.
         * @returns {Promise} - Resolves to the value passed to the function
         * @example
         * const rollFunction &#x3D; async function(){
         *  //Get the result of a choose from list query
         *  const queryResult &#x3D; await pseudoQuery(&#x27;a value&#x27;);
         *  console.log(queryResult);//&#x3D;&gt; &quot;a value&quot;
         * }
         */
        const pseudoQuery &#x3D; async function(value){
        	debug(&#x27;entering pseudoQuery&#x27;);
        	let queryRoll &#x3D; await startRoll(&#x60;!{{query&#x3D;[[0[response&#x3D;${value}]]]}}&#x60;);
        	finishRoll(queryRoll.rollId);
        	return queryRoll.results.query.expression.replace(/^.+?response&#x3D;|\]$/g,&#x27;&#x27;);
        };
        kFuncs.pseudoQuery &#x3D; pseudoQuery;
        
        /**
         * An alias for console.log.
         * @param {any} msg - The message can be a straight string, an object, or an array. If it is an object or array, the object will be broken down so that each key is used as a label to output followed by the value of that key. If the value of the key is an object or array, it will be output via &#x60;console.table&#x60;.
         */
        const log &#x3D; function(msg){
          if(typeof msg &#x3D;&#x3D;&#x3D; &#x27;string&#x27;){
            console.log(&#x60;%c${kFuncs.sheetName} log| ${msg}&#x60;,&quot;background-color:#159ccf&quot;);
          }else if(typeof msg &#x3D;&#x3D;&#x3D; &#x27;object&#x27;){
            Object.keys(msg).forEach((m)&#x3D;&gt;{
              if(typeof msg[m] &#x3D;&#x3D;&#x3D; &#x27;string&#x27;){
                console.log(&#x60;%c${kFuncs.sheetName} log| ${m}: ${msg[m]}&#x60;,&quot;background-color:#159ccf&quot;);
              }else{
                console.log(&#x60;%c${kFuncs.sheetName} log| ${typeof msg[m]} ${m}&#x60;,&quot;background-color:#159ccf&quot;);
                console.table(msg[m]);
              }
            });
          }
        };
        kFuncs.log &#x3D; log;
        
        /**
         * Alias for console.log that only triggers when debug mode is enabled or when the sheet\&#x27;s version is &#x60;0&#x60;. Useful for entering test logs that will not pollute the console on the live sheet.
         * @param {any} msg - &#x27;See {@link k.log}
         * @param {boolean} force - Pass as a truthy value to force the debug output to be output to the console regardless of debug mode.
         * @returns {void}
         */
        const debug &#x3D; function(msg,force){
          if(!kFuncs.debugMode &amp;&amp; !force &amp;&amp; kFuncs.version &gt; 0) return;
          if(typeof msg &#x3D;&#x3D;&#x3D; &#x27;string&#x27;){
            console.log(&#x60;%c${kFuncs.sheetName} DEBUG| ${msg}&#x60;,&quot;background-color:tan;color:red;&quot;);
          }else if(typeof msg &#x3D;&#x3D;&#x3D; &#x27;object&#x27;){
            Object.keys(msg).forEach((m)&#x3D;&gt;{
              if(typeof msg[m] &#x3D;&#x3D;&#x3D; &#x27;string&#x27;){
                console.log(&#x60;%c${kFuncs.sheetName} DEBUG| ${m}: ${msg[m]}&#x60;,&quot;background-color:tan;color:red;&quot;);
              }else{
                console.log(&#x60;%c${kFuncs.sheetName} DEBUG| ${typeof msg[m]} ${m}&#x60;,&quot;background-color:tan;color:red;font-weight:bold;&quot;);
                console.table(msg[m]);
              }
            });
          }
        };
        kFuncs.debug &#x3D; debug;
        
        /**
         * Orders the section id arrays for all sections in the &#x60;sections&#x60; object to match the repOrder attribute.
         * @param {attributesProxy} attributes - The attributes object that must have a value for the reporder for each section.
         * @param {object[]} sections - Object containing the IDs for the repeating sections, indexed by repeating section name.
         */
        const orderSections &#x3D; function(attributes,sections){
          Object.keys(sections).forEach((section)&#x3D;&gt;{
            attributes.attributes[&#x60;_reporder_${section}&#x60;] &#x3D; commaArray(attributes[&#x60;_reporder_${section}&#x60;]);
            orderSection(attributes.attributes[&#x60;_reporder_${section}&#x60;],sections[section]);
          });
        };
        kFuncs.orderSections &#x3D; orderSections;
        
        /**
         * Orders a single ID array.
         * @param {string[]} repOrder - Array of IDs in the order they are in on the sheet.
         * @param {string[]} IDs - Array of IDs to be ordered.
         */
        const orderSection &#x3D; function(repOrder,IDs&#x3D;[]){
          IDs.sort((a,b)&#x3D;&gt;{
            return repOrder.indexOf(a.toLowerCase()) - repOrder.indexOf(b.toLowerCase());
          });
        };
        kFuncs.orderSection &#x3D; orderSection;
        
        /**
         * Splits a comma delimited string into an array
         * @param {string} string - The string to split.
         * @returns {array} - The string segments of the comma delimited list.
         */
        const commaArray &#x3D; function(string&#x3D;&#x27;&#x27;){
          return string.toLowerCase().split(/\s*,\s*/);
        };
        kFuncs.commaArray &#x3D; commaArray;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
        /*jshint -W014,-W084,-W030,-W033*/
        //# Attribute Obj Proxy handler
        const createAttrProxy &#x3D; function(attrs){
          //creates a proxy for the attributes object so that values can be worked with more easily.
          const getCascObj &#x3D; function(event,casc){
            const eventName &#x3D; event.triggerName || event.sourceAttribute;
            let typePrefix &#x3D; eventName.startsWith(&#x27;clicked:&#x27;) ?
              &#x27;act_&#x27; :
              event.removedInfo ?
              &#x27;fieldset_&#x27; :
              &#x27;attr_&#x27;;
            let cascName &#x3D; &#x60;${typePrefix}${eventName.replace(/(?:removed|clicked):/,&#x27;&#x27;)}&#x60;;
            let cascObj &#x3D; casc[cascName];
            if(typePrefix &#x3D;&#x3D;&#x3D; &#x27;attr_&#x27;){
              cascObj.previousValue &#x3D; event.previousValue;
            }
            return cascObj;
          };
          
          const triggerFunctions &#x3D; function(obj,attributes,sections){
            if(obj.triggeredFuncs &amp;&amp; obj.triggeredFuncs.length){
              debug(&#x60;triggering functions for ${obj.name}&#x60;);
              obj.triggeredFuncs &amp;&amp; obj.triggeredFuncs.forEach(func&#x3D;&gt;funcs[func] ? 
                funcs[func]({trigger:obj,attributes,sections}) :
                debug(&#x60;!!!Warning!!! no function named ${func} found. Triggered function not called for ${obj.name}&#x60;,true));
            }
          };
          
          const initialFunction &#x3D; function(obj,attributes,sections){
            if(obj.initialFunc){
              debug(&#x60;initial functions for ${obj.name}&#x60;);
              funcs[obj.initialFunc] ?
                funcs[obj.initialFunc]({trigger:obj,attributes,sections}) :
                debug(&#x60;!!!Warning!!! no function named ${obj.initialFunc} found. Initial function not called for ${obj.name}&#x60;,true);
            }
          };
          const alwaysFunctions &#x3D; function(trigger,attributes,sections,casc){
            Object.values(allHandlers).forEach((handler)&#x3D;&gt;{
              handler({trigger,attributes,sections,casc});
            });
          };
          const processChange &#x3D; function({event,trigger,attributes,sections,casc}){
            if(event &amp;&amp; !trigger){
              debug(&#x60;${event.sourceAttribute} change detected. No trigger found&#x60;);
              return;
            }
            if(!attributes || !sections || !casc){
              debug(&#x60;!!! Insufficient arguments || attributes &gt; ${!!attributes} | sections &gt; ${!!sections} | casc &gt; ${!!casc} !!!&#x60;);
              return;
            }
            debug({trigger});
            if(event){
              debug(&#x27;checking for initial &amp; always functions&#x27;);
              alwaysFunctions(trigger,attributes,sections,casc);//Functions that should be run for all events.
              initialFunction(trigger,attributes,sections,casc);//functions that should only be run if the attribute was the thing changed by the user
            }
            if(trigger){
              debug(&#x60;processing ${trigger.name}&#x60;);
              triggerFunctions(trigger,attributes,sections,casc);
              if(!event &amp;&amp; trigger.calculation &amp;&amp; funcs[trigger.calculation]){
                attributes[trigger.name] &#x3D; funcs[trigger.calculation]({trigger,attributes,sections,casc});
              }else if(trigger.calculation &amp;&amp; !funcs[trigger.calculation]){
                debug(&#x60;K-Scaffold Error: No function named ${trigger.calculation} found&#x60;);
              }
              if(Array.isArray(trigger.affects)){
                attributes.queue.push(...trigger.affects);
              }
            }
            attributes.set({attributes,sections,casc});
          };
          const attrTarget &#x3D; {
            updates:{},
            attributes:{...attrs},
            repOrders:{},
            queue: [],
            casc:{},
            alwaysFunctions,
            processChange,
            triggerFunctions,
            initialFunction,
            getCascObj
          };
          const attrHandler &#x3D; {
            get:function(obj,prop){//gets the most value of the attribute.
              //If it is a repeating order, returns the array, otherwise returns the update value or the original value
              if(prop &#x3D;&#x3D;&#x3D; &#x27;set&#x27;){
                return function(){
                  let {attributes,sections,casc,callback,vocal} &#x3D; arguments[0] ? arguments[0] : {};
                  if(attributes &amp;&amp; attributes.queue.length &amp;&amp; sections &amp;&amp; casc){
                    let triggerName &#x3D; attributes.queue.shift();
                    let trigger &#x3D; getCascObj({sourceAttribute:triggerName},casc);
                    attributes.processChange({trigger,attributes,sections,casc});
                  }else{
                    debug({updates:obj.updates});
                    let trueCallback &#x3D; Object.keys(obj.repOrders).length ?
                      function(){
                        Object.entries(obj.repOrders).forEach(([section,order])&#x3D;&gt;{
                          _setSectionOrder(section,order,)
                        });
                        callback &amp;&amp; callback();
                      }:
                      callback;
                    Object.keys(obj.updates).forEach((key)&#x3D;&gt;obj.attributes[key] &#x3D; obj.updates[key]);
                    const update &#x3D; obj.updates;
                    obj.updates &#x3D; {};
                    set(update,vocal,trueCallback);
                  }
                }
              }else if(Object.keys(obj).some(key&#x3D;&gt;key&#x3D;&#x3D;&#x3D;prop)){ 
                return Reflect.get(...arguments)
              }else{
                let retValue;
                switch(true){
                  case obj.repOrders.hasOwnProperty(prop):
                    retValue &#x3D; obj.repOrders[prop];
                    break;
                  case obj.updates.hasOwnProperty(prop):
                    retValue &#x3D; obj.updates[prop];
                    break;
                  default:
                    retValue &#x3D; obj.attributes[prop];
                    break;
                }
                let cascRef &#x3D; &#x60;attr_${prop.replace(/(repeating_[^_]+_)[^_]+/,&#x27;$1\$X&#x27;)}&#x60;;
                let numRetVal &#x3D; +retValue;
                if(!Number.isNaN(numRetVal) &amp;&amp; retValue !&#x3D;&#x3D; &#x27;&#x27;){
                  retValue &#x3D; numRetVal;
                }else if(cascades[cascRef] &amp;&amp; (typeof cascades[cascRef].defaultValue &#x3D;&#x3D;&#x3D; &#x27;number&#x27; || cascades[cascRef].type &#x3D;&#x3D;&#x3D; &#x27;number&#x27;)){
                  retValue &#x3D; cascades[cascRef].defaultValue;
                }
                return retValue;
              }
            },
            set:function(obj,prop,value){
              //Sets the value. Also verifies that the value is a valid attribute value
              //e.g. not undefined, null, or NaN
              if(value || value&#x3D;&#x3D;&#x3D;0 || value&#x3D;&#x3D;&#x3D;&#x27;&#x27;){
                if(/reporder|^repeating_[^_]+$/.test(prop)){
                  let section &#x3D; prop.replace(/_reporder_/,&#x27;&#x27;);
                  obj.repOrders[section] &#x3D; value;
                }else if(&#x60;${obj.attributes}&#x60; !&#x3D;&#x3D; &#x60;${value}&#x60; || 
                  (obj.updates[prop] &amp;&amp; &#x60;${obj.updates}&#x60; !&#x3D;&#x3D; &#x60;${value}&#x60;)
                ){
                  obj.updates[prop] &#x3D; value;
                }
              }else{
                debug(&#x60;!!!Warning: Attempted to set ${prop} to an invalid value:${value}; value not stored!!!&#x60;);
              }
              return true;
            },
            deleteProperty(obj,prop){
              //removes the property from the original attributes, updates, and the reporders
              Object.keys(obj).forEach((key)&#x3D;&gt;{
                delete obj[key][prop.toLowerCase()];
              });
            }
          };
          return new Proxy(attrTarget,attrHandler);
        };
        
        
        /**
         * Function that registers a function for being called via the funcs object. Returns true if the function was successfully registered, and false if it could not be registered for any reason.
         * @param {object} funcObj - Object with keys that are names to register functions under and values that are functions.
         * @param {object} optionsObj - Object that contains options to use for this registration.
         * @param {string[]} optionsObj.type - Array that contains the types of specialized functions that apply to the functions being registered. Valid types are &#x60;&quot;opener&quot;&#x60;, &#x60;&quot;updater&quot;&#x60;, and &#x60;&quot;default&quot;&#x60;. &#x60;&quot;default&quot;&#x60; is always used, and never needs to be passed.
         * @returns {boolean} - True if the registration succeeded, false if it failed.
         * @example
         * //Basic Registration
         * const myFunc &#x3D; function({trigger,attributes,sections,casc}){};
         * k.registerFuncs({myFunc});
         * 
         * //Register a function to run on sheet open
         * const openFunc &#x3D; function({trigger,attributes,sections,casc}){};
         * k.registerFuncs({openFunc},{type:[&#x27;opener&#x27;]})
         * 
         * //Register a function to run on all events
         * const allFunc &#x3D; function({trigger,attributes,sections,casc}){};
         * k.registerFuncs({allFunc},{type:[&#x27;all&#x27;]})
         */
        const registerFuncs &#x3D; function(funcObj,optionsObj &#x3D; {}){
          if(typeof funcObj !&#x3D;&#x3D; &#x27;object&#x27; || typeof optionsObj !&#x3D;&#x3D; &#x27;object&#x27;){
            debug(&#x60;!!!! K-scaffold error: Improper arguments to register functions !!!!&#x60;);
            return false;
          }
          const typeArr &#x3D; optionsObj.type ? [&#x27;default&#x27;,...optionsObj.type] : [&#x27;default&#x27;];
          const typeSwitch &#x3D; {
            &#x27;opener&#x27;:openHandlers,
            &#x27;updater&#x27;:updateHandlers,
            &#x27;new&#x27;:initialSetups,
            &#x27;all&#x27;:allHandlers,
            &#x27;default&#x27;:funcs
          };
          let setState;
          Object.entries(funcObj).map(([prop,value])&#x3D;&gt;{
            typeArr.forEach((type)&#x3D;&gt;{
              if(typeSwitch[type][prop]){
                debug(&#x60;!!! Duplicate function name for ${prop} as ${type}!!!&#x60;);
                setState &#x3D; false;
              }else if(typeof value &#x3D;&#x3D;&#x3D; &#x27;function&#x27;){
                typeSwitch[type][prop] &#x3D; value;
                setState &#x3D; setState !&#x3D;&#x3D; false ? true : false;
              }else{
                debug(&#x60;!!! K-scaffold error: Function registration requires a function. Invalid value to register as ${type} !!!&#x60;);
                setState &#x3D; false;
              }
            });
          });
          return setState;
        };
        kFuncs.registerFuncs &#x3D; registerFuncs;
        
        const setActionCalls &#x3D; function({attributes,sections}){
          actionAttributes.forEach((base)&#x3D;&gt;{
            let [section,,field] &#x3D; k.parseTriggerName(base);
            let fieldAction &#x3D; field.replace(/_/g,&#x27;-&#x27;);
            if(section){
              sections[section].forEach((id)&#x3D;&gt;{
                attributes[&#x60;${section}_${id}_${field}&#x60;] &#x3D; &#x60;%{${attributes.character_name}|${section}_${id}_${fieldAction}}&#x60;;
              });
            }else{
              attributes[&#x60;${field}&#x60;] &#x3D; &#x60;%{${attributes.character_name}|${fieldAction}}&#x60;;
            }
          });
        };
        funcs.setActionCalls &#x3D; setActionCalls;
        
        /**
         * Function to call a function previously registered to the funcs object. May not be used that much. Either returns the function or null if no function exists.
         * @param {string} funcName - The name of the function to invoke.
         * @param {...any} args - The arguments to call the function with.
         * @returns {any}
         * @example
         * //Call myFunc with two arguments
         * k.callFunc(&#x27;myFunc&#x27;,&#x27;an argument&#x27;,&#x27;another argument&#x27;);
         */
        const callFunc &#x3D; function(funcName,...args){
          if(funcs[funcName]){
            debug(&#x60;calling ${funcName}&#x60;);
            return funcs[funcName](...args);
          }else{
            debug(&#x60;Invalid function name: ${funcName}&#x60;);
            return null;
          }
        };
        kFuncs.callFunc &#x3D; callFunc;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
        /*jshint -W014,-W084,-W030,-W033*/
        //Sheet Updaters and styling functions
        const updateSheet &#x3D; function(){
          log(&#x27;updating sheet&#x27;);
          getAllAttrs({props:[&#x27;debug_mode&#x27;,...baseGet],callback:(attributes,sections,casc)&#x3D;&gt;{
            kFuncs.debugMode &#x3D; kFuncs.debugMode || !!attributes.debug_mode;
            debug({sheet_version:attributes.sheet_version});
            if(!attributes.sheet_version){
              Object.entries(initialSetups).forEach(([funcName,handler])&#x3D;&gt;{
                if(typeof funcs[funcName] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;){
                  debug(&#x60;running ${funcName}&#x60;);
                  funcs[funcName]({attributes,sections,casc});
                }else{
                  debug(&#x60;!!!Warning!!! no function named ${funcName} found. Initial sheet setup not performed.&#x60;);
                }
              });
            }else{
              Object.entries(updateHandlers).forEach(([ver,handler])&#x3D;&gt;{
                if(attributes.sheet_version &lt; +ver){
                  handler({attributes,sections,casc});
                }
              });
            }
            Object.entries(openHandlers).forEach(([funcName,func])&#x3D;&gt;{
              if(typeof funcs[funcName] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;){
                debug(&#x60;running ${funcName}&#x60;);
                funcs[funcName]({attributes,sections,casc});
              }else{
                debug(&#x60;!!!Warning!!! no function named ${funcName} found. Sheet open handling not performed.&#x60;);
              }
            });
            setActionCalls({attributes,sections});
            attributes.sheet_version &#x3D; kFuncs.version;
            log(&#x60;Sheet Update applied. Current Sheet Version ${kFuncs.version}&#x60;);
            attributes.set();
            log(&#x27;Sheet ready for use&#x27;);
          }});
        };
        
        const initialSetup &#x3D; function(attributes,sections){
          debug(&#x27;Initial sheet setup&#x27;);
        };
        
        /**
         * This is the default listener function for attributes that the K-Scaffold uses. It utilizes the &#x60;triggerFuncs&#x60;, &#x60;listenerFunc&#x60;, &#x60;calculation&#x60;, and &#x60;affects&#x60; properties of the K-scaffold trigger object (see the Pug section of the scaffold for more details).
         * @param {Roll20Event} event - The Roll20 event object
         * @returns {void}
         * @example
         * //Call from an attribute change
         * on(&#x27;change:an_attribute&#x27;,k.accessSheet);
         */
        const accessSheet &#x3D; function(event){
          debug({funcs:Object.keys(funcs)});
          debug({event});
          getAllAttrs({callback:(attributes,sections,casc)&#x3D;&gt;{
            let trigger &#x3D; attributes.getCascObj(event,casc);
            attributes.processChange({event,trigger,attributes,sections,casc});
          }});
        };
        funcs.accessSheet &#x3D; accessSheet;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
        /*jshint -W014,-W084,-W030,-W033*/
        /*
        Cascade Expansion functions
        */
        //Expands the repeating section templates in cascades to reflect the rows actually available
        const expandCascade &#x3D; function(cascade,sections,attributes){
          return _.keys(cascade).reduce((memo,key)&#x3D;&gt;{//iterate through cascades and replace references to repeating attributes with correct row ids.
            if(/^(?:act|attr)_repeating_/.test(key)){//If the attribute is a repeating attribute, do special logic
              expandRepeating(memo,key,cascade,sections,attributes);
            }else if(key){//for non repeating attributes do this logic
              expandNormal(memo,key,cascade,sections);
            }
            return memo;
          },{});
        };
        
        const expandRepeating &#x3D; function(memo,key,cascade,sections,attributes){
          key.replace(/((?:attr|act)_)(repeating_[^_]+)_[^_]+?_(.+)/,(match,type,section,field)&#x3D;&gt;{
            (sections[section]||[]).forEach((id)&#x3D;&gt;{
              memo[&#x60;${type}${section}_${id}_${field}&#x60;]&#x3D;_.clone(cascade[key]);//clone the details so that each row&#x27;s attributes have correct ids
              memo[&#x60;${type}${section}_${id}_${field}&#x60;].name &#x3D; &#x60;${section}_${id}_${field}&#x60;;
              if(key.startsWith(&#x27;attr_&#x27;)){
                memo[&#x60;${type}${section}_${id}_${field}&#x60;].affects &#x3D; memo[&#x60;${type}${section}_${id}_${field}&#x60;].affects.reduce((m,affected)&#x3D;&gt;{
                  if(section &#x3D;&#x3D;&#x3D; affected){//otherwise if the affected attribute is in the same section, simply set the affected attribute to have the same row id.
                    m.push(applyID(affected,id));
                  }else if(/repeating/.test(affected)){//If the affected attribute isn&#x27;t in the same repeating section but is still a repeating attribute, add all the rows of that section
                    addAllRows(affected,m,sections);
                  }else{//otherwise the affected attribute is a non repeating attribute. Simply add it to the computed affected array
                    m.push(affected);
                  }
                  return m;
                },[]);
              }
            });
          });
        };
        
        const applyID &#x3D; function(affected,id){
          return affected.replace(/(repeating_[^_]+_)[^_]+(.+)/,&#x60;$1${id}$2&#x60;);
        };
        
        const expandNormal &#x3D; function(memo,key,cascade,sections){
          memo[key] &#x3D; _.clone(cascade[key]);
          if(key.startsWith(&#x27;attr_&#x27;)){
            memo[key].affects &#x3D; memo[key].affects || [];
            memo[key].affects &#x3D; memo[key].affects.reduce((m,a)&#x3D;&gt;{
              if(/^repeating/.test(a)){
                addAllRows(a,m,sections);
              }else{
                m.push(a);
              }
              return m;
            },[]);
          }
        };
        
        const addAllRows &#x3D; function(affected,memo,sections){
          affected.replace(/(repeating_[^_]+?)_[^_]+?_(.+)/,(match,section,field)&#x3D;&gt;{
            sections[section].forEach(id&#x3D;&gt;memo.push(&#x60;${section}_${id}_${field}&#x60;));
          });
        };/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
        /*jshint -W014,-W084,-W030,-W033*/
        /**
         * Alias for [setSectionOrder()](https://wiki.roll20.net/Sheet_Worker_Scripts#setSectionOrder.28.3CRepeating_Section_Name.3E.2C_.3CSection_Array.3E.2C_.3CCallback.3E.29) that allows you to use the section name in either &#x60;repeating_section&#x60; or &#x60;section&#x60; formats. Note that the Roll20 sheetworker [setSectionOrder](https://wiki.roll20.net/Sheet_Worker_Scripts#setSectionOrder.28.3CRepeating_Section_Name.3E.2C_.3CSection_Array.3E.2C_.3CCallback.3E.29) currently causes some display issues on sheets.
         * @name setSectionOrder
         * @param {string} section - The name of the section, with or without &#x60;repeating_&#x60;
         * @param {string[]} order - Array of ids describing the desired order of the section.
         * @returns {void}
         * @example
         * //Set the order of a repeating_weapon section
         * k.setSectionOrder(&#x27;repeating_equipment&#x27;,[&#x27;id1&#x27;,&#x27;id2&#x27;,&#x27;id3&#x27;]);
         * //Can also specify the section name without the repeating_ prefix
         * k.setSectionOrder(&#x27;equipment&#x27;,[&#x27;id1&#x27;,&#x27;id2&#x27;,&#x27;id3&#x27;]);
         */
        const _setSectionOrder &#x3D; function(section,order){
          let trueSection &#x3D; section.replace(/repeating_/,&#x27;&#x27;);
          setSectionOrder(trueSection,order);
        };
        kFuncs.setSectionOrder &#x3D; _setSectionOrder;
        
        /**
         * Alias for [removeRepeatingRow](https://wiki.roll20.net/Sheet_Worker_Scripts#removeRepeatingRow.28_RowID_.29) that also removes the row from the current object of attribute values and array of section IDs to ensure that erroneous updates are not issued.
         * @name removeRepeatingRow
         * @param {string} row - The row id to be removed
         * @param {attributesProxy} attributes - The attribute values currently in memory
         * @param {object} sections - Object that contains arrays of all the IDs in sections on the sheet indexed by repeating name.
         * @returns {void}
         * @example
         * //Remove a repeating Row
         * k.getAllAttrs({
         *  callback:(attributes,sections)&#x3D;&gt;{
         *    const rowID &#x3D; sections.repeating_equipment[0];
         *    k.removeRepeatingRow(&#x60;repeating_equipment_${rowID}&#x60;,attributes,sections);
         *    console.log(sections.repeating_equipment); // &#x3D;&gt; rowID no longer exists in the array.
         *    console.log(attributes[&#x60;repeating_equipment_${rowID}_name&#x60;]); // &#x3D;&gt; undefined
         *  }
         * })
         */
        const _removeRepeatingRow &#x3D; function(row,attributes,sections){
          debug(&#x60;removing ${row}&#x60;);
          Object.keys(attributes.attributes).forEach((key)&#x3D;&gt;{
            if(key.startsWith(row)){
              delete attributes[key];
            }
          });
          let [,section,rowID] &#x3D; row.match(/(repeating_[^_]+)_(.+)/,&#x27;&#x27;);
          sections[section] &#x3D; sections[section].filter((id)&#x3D;&gt;id!&#x3D;&#x3D;rowID);
          removeRepeatingRow(row);
        };
        kFuncs.removeRepeatingRow &#x3D; _removeRepeatingRow;
        
        /**
         * Alias for [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29) that converts the default object of attribute values into an {@link attributesProxy} and passes that back to the callback function.
         * @name getAttrs
         * @param {string[]} [props&#x3D;baseGet] - Array of attribute names to get the value of. Defaults to {@link baseGet} if not passed.
         * @param {function(attributesProxy)} callback - The function to call after the attribute values have been gotten. An {@link attributesProxy} is passed to the callback.
         * @example
         * //Gets the attributes named in props.
         * k.getAttrs({
         *  props:[&#x27;attribute_1&#x27;,&#x27;attribute_2&#x27;],
         *  callback:(attributes)&#x3D;&gt;{
         *    //Work with the attributes as you would in a normal getAttrs, or use the superpowers of the K-scaffold attributes object like so:
         *    attributes.attribute_1 &#x3D; &#x27;new value&#x27;;
         *    attributes.set();
         *  }
         * })
         */
        const _getAttrs &#x3D; function({props&#x3D;baseGet,callback}){
          getAttrs(props,(values)&#x3D;&gt;{
            const attributes &#x3D; createAttrProxy(values);
            callback(attributes);
          });
        };
        kFuncs.getAttrs &#x3D; _getAttrs;
        
        /**
         * Alias for [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29) and [getSectionIDs](https://wiki.roll20.net/Sheet_Worker_Scripts#getSectionIDs.28section_name.2Ccallback.29) that combines the actions of both sheetworker functions and converts the default object of attribute values into an {@link attributesProxy}. Also gets the details on how to handle all attributes from the master {@link cascades} object and.
         * @param {Object} args
         * @param {string[]} [args.props&#x3D;baseGet] - Array of attribute names to get the value of. Defaults to {@link baseGet} if not passed.
         * @param {repeatingSectionDetails} sectionDetails - Array of details about a section to get the IDs for and attributes that need to be gotten. 
         * @param {function(attributesProxy,sectionObj,expandedCascade):void} args.callback - The function to call after the attribute values have been gotten. An {@link attributesProxy} is passed to the callback along with a {@link sectionObj} and {@link expandedCascade}.
         * @example
         * //Get every K-scaffold linked attribute on the sheet
         * k.getAllAttrs({
         *  callback:(attributes,sections,casc)&#x3D;&gt;{
         *    //Work with the attributes as you please.
         *    attributes.some_attribute &#x3D; &#x27;a value&#x27;;
         *    attributes.set();//Apply our change
         *  }
         * })
         */
        const getAllAttrs &#x3D; function({props&#x3D;baseGet,sectionDetails&#x3D;repeatingSectionDetails,callback}){
          getSections(sectionDetails,(repeats,sections)&#x3D;&gt;{
            getAttrs([...props,...repeats],(values)&#x3D;&gt;{
              const attributes &#x3D; createAttrProxy(values);
              orderSections(attributes,sections);
              const casc &#x3D; expandCascade(cascades,sections,attributes);
              callback(attributes,sections,casc);
            })
          });
        };
        kFuncs.getAllAttrs &#x3D; getAllAttrs;
        
        /**
         * Alias for [getSectionIDs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getSectionIDs.28section_name.2Ccallback.29) that allows you to iterate through several functions at once. Also assembles an array of repeating attributes to get.
         * @param {object[]} sectionDetails - Array of details about a section to get the IDs for and attributes that need to be gotten.
         * @param {string} sectionDetails.section - The full name of the repeating section including the &#x60;repeating_&#x60; prefix.
         * @param {string[]} sectionDetails.fields - Array of field names that need to be gotten from the repeating section
         * @param {function(string[],sectionObj)} callback - The function to call once all IDs have been gotten and the array of repating attributes to get has been assembled. The callback is passed the array of repating attributes to get and a {@link sectionObj}.
         * @example
         * // Get some section details
         * const sectionDetails &#x3D; {
         *  {section:&#x27;repeating_equipment&#x27;,fields:[&#x27;name&#x27;,&#x27;weight&#x27;,&#x27;cost&#x27;]},
         *  {section:&#x27;repeating_weapon&#x27;,fields:[&#x27;name&#x27;,&#x27;attack&#x27;,&#x27;damage&#x27;]}
         * };
         * k.getSections(sectionDetails,(attributeNames,sections)&#x3D;&gt;{
         *  console.log(attributeNames);// &#x3D;&gt; Array containing all row specific attribute names
         *  console.log(sections);// &#x3D;&gt; Object with arrays containing the row ids. Indexed by section name (e.g. repeating_eqiupment)
         * })
         */
        const getSections &#x3D; function(sectionDetails,callback){
          let queueClone &#x3D; _.clone(sectionDetails);
          const worker &#x3D; (queue,repeatAttrs&#x3D;[],sections&#x3D;{})&#x3D;&gt;{
            let detail &#x3D; queue.shift();
            getSectionIDs(detail.section,(IDs)&#x3D;&gt;{
              sections[detail.section] &#x3D; IDs;
              IDs.forEach((id)&#x3D;&gt;{
                detail.fields.forEach((f)&#x3D;&gt;{
                  repeatAttrs.push(&#x60;${detail.section}_${id}_${f}&#x60;);
                });
              });
              repeatAttrs.push(&#x60;_reporder_${detail.section}&#x60;);
              if(queue.length){
                worker(queue,repeatAttrs,sections);
              }else{
                callback(repeatAttrs,sections);
              }
            });
          };
          if(!queueClone[0]){
            callback([],{});
          }else{
            worker(queueClone);
          }
        };
        kFuncs.getSections &#x3D; getSections;
        
        // Sets the attributes while always calling with {silent:true}
        // Can be awaited to get the values returned from _setAttrs
        /**
         * Alias for [setAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#setAttrs.28values.2Coptions.2Ccallback.29) that sets silently by default.
         * @param {object} obj - The object containting attributes to set
         * @param {boolean} [vocal&#x3D;false] - Whether to set silently (default value) or not.
         * @param {function()} [callback] - The callback function to invoke after the setting has been completed. No arguments are passed to the callback function.
         * @example
         * //Set some attributes silently
         * k.setAttrs({attribute_1:&#x27;new value&#x27;})
         * //Set some attributes and triggers listeners
         * k.setAttrs({attribute_1:&#x27;new value&#x27;,true})
         * //Set some attributes and call a callback function
         * k.setAttrs({attribute_1:&#x27;new value&#x27;},null,()&#x3D;&gt;{
         *  //Do something after the attribute is set
         * })
         */
        const set &#x3D; function(obj,vocal&#x3D;false,callback){
          setAttrs(obj,{silent:!vocal},callback);
        };
        kFuncs.setAttrs &#x3D; set;
        
        const generateCustomID &#x3D; function(string){
          if(!string.startsWith(&#x27;-&#x27;)){
            string &#x3D; &#x60;-${string}&#x60;;
          }
          rowID &#x3D; generateRowID();
          let re &#x3D; new RegExp(&#x60;^.{${string.length}}&#x60;);
          return &#x60;${string}${rowID.replace(re,&#x27;&#x27;)}&#x60;;
        };
        
        
        /**
         * Alias for generateRowID that adds the new id to the {@link sectionObj}. Also allows for creation of custom IDs that conform to the section ID requirements.
         * @name generateRowID
         * @param {sectionObj} sections
         * @param {string} [customText] - Custom text to start the ID with. This text should not be longer than the standard repeating section ID format.
         * @returns {string} - The created ID
         * @example
         * k.getAllAttrs({
         *  callback:(attributes,sections,casc)&#x3D;&gt;{
         *    //Create a new row ID
         *    const rowID &#x3D; k.generateRowID(&#x27;repeating_equipment&#x27;,sections);
         *    console.log(rowID);// &#x3D;&gt; -p8rg908ug0suzz
         *    //Create a custom row ID
         *    const customID &#x3D; k.generateRowID(&#x27;repeating_equipment&#x27;,sections,&#x27;custom&#x27;);
         *    console.log(customID);// &#x3D;&gt; -custom98uadj89kj
         *  }
         * });
         */
        const _generateRowID &#x3D; function(section,sections,customText){
          let rowID &#x3D; customText ?
            generateCustomID(customText) :
            generateRowID();
          section &#x3D; section.match(/^repeating_[^_]+$/) ?
            section :
            &#x60;repeating_${section}&#x60;;
          sections[section] &#x3D; sections[section] || [];
          sections[section].push(rowID);
          return &#x60;${section}_${rowID}&#x60;;
        };
        kFuncs.generateRowID &#x3D; _generateRowID;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
        /*jshint -W014,-W084,-W030,-W033*/
        const listeners &#x3D; {};
        const baseGet &#x3D; Object.entries(cascades).reduce((memo,[attrName,detailObj])&#x3D;&gt;{
          if(!/repeating/.test(attrName) &amp;&amp; detailObj.type !&#x3D;&#x3D; &#x27;action&#x27;){
            memo.push(detailObj.name);
          }
          if(detailObj.listener){
            listeners[detailObj.listener] &#x3D; detailObj.listenerFunc;
          }
          return memo;
        },[]);
        kFuncs.baseGet &#x3D; baseGet;
        const registerEventHandlers &#x3D; function(){
          on(&#x27;sheet:opened&#x27;,updateSheet);
          debug({funcKeys:Object.keys(funcs),funcs});
          //Roll20 change and click listeners
          Object.entries(listeners).forEach(([event,funcName])&#x3D;&gt;{
            if(funcs[funcName]){
              on(event,funcs[funcName]);
            }else{
              debug(&#x60;!!!Warning!!! no function named ${funcName} found. No listener created for ${event}&#x60;,true);
            }
          });
          log(&#x60;kScaffold Loaded&#x60;);
        };
        setTimeout(registerEventHandlers,0);//Delay the execution of event registration to ensure all event properties are present.
        
        const addItem &#x3D; function(event){
          let [,,section] &#x3D; parseClickTrigger(event.triggerName);
          section &#x3D; section.replace(/add-/,&#x27;&#x27;);
          getAllAttrs({
            callback:(attributes,sections,casc) &#x3D;&gt; {
              let row &#x3D; _generateRowID(section,sections);
              debug({row});
              attributes[&#x60;${row}_name&#x60;] &#x3D; &#x27;&#x27;;
              setActionCalls({attributes,sections});
              const trigger &#x3D; cascades[&#x60;fieldset_repeating_${section}&#x60;];
              if(trigger &amp;&amp; trigger.addFuncs){
                trigger.addFuncs.forEach((funcName) &#x3D;&gt; {
                  if(funcs[funcName]){
                    funcs[funcName]({attributes,sections,casc,trigger});
                  }
                });
              }
              attributes.set({attributes,sections,casc});
            }
          });
        };
        funcs.addItem &#x3D; addItem;
        
        const editSection &#x3D; function(event){
          let [,,section] &#x3D; parseClickTrigger(event.triggerName);
          section &#x3D; section.replace(/edit-/,&#x27;&#x27;);
          let target &#x3D; &#x60;fieldset.repeating_${section} + .repcontainer&#x60;;
          $20(target).toggleClass(&#x27;ui-sortable&#x27;);
          $20(target).toggleClass(&#x27;editmode&#x27;);
        };
        registerFuncs({editSection});/**
         * The default tab navigation function of the K-scaffold. Courtesy of Riernar. It will add &#x60;k-active-tab&#x60; to the active tab-container and &#x60;k-active-button&#x60; to the active button. You can either write your own CSS to control display of these, or use the default CSS included in &#x60;scaffold/_k.scss&#x60;. Note that &#x60;k-active-button&#x60; has no default CSS as it is assumed that you will want to style the active button to match your system.
         * @param {Object} trigger - The trigger object
         */
        const kSwitchTab &#x3D; function ({ trigger, attributes }) {
          const [container, tab] &#x3D; (
            trigger.name.match(/nav-tabs-(.+)--(.+)/) ||
            []
          ).slice(1);
          $20(&#x60;[data-container-tab&#x3D;&quot;${container}&quot;]&#x60;).removeClass(&#x27;k-active-tab&#x27;);
          $20(&#x60;[data-container-tab&#x3D;&quot;${container}&quot;][data-tab&#x3D;&quot;${tab}&quot;]&#x60;).addClass(&#x27;k-active-tab&#x27;);
          $20(&#x60;[data-container-button&#x3D;&quot;${container}&quot;]&#x60;).removeClass(&#x27;k-active-button&#x27;);
          $20(&#x60;[data-container-button&#x3D;&quot;${container}&quot;][data-button&#x3D;&quot;${tab}&quot;]&#x60;).addClass(&#x27;k-active-button&#x27;);
          const tabInputName &#x3D; &#x60;${container.replace(/\-/g,&#x27;_&#x27;)}_tab&#x60;;
          if(persistentTabs.indexOf(tabInputName) &gt; -1){
            attributes[tabInputName] &#x3D; trigger.name;
          }
        }
        
        registerFuncs({ kSwitchTab });
        
        /**
         * Sets persistent tabs to their last active state
         * @param {object} trigger - The trigger that caused the function to be called
         * @param {object} attributes - The attribute values of the character
         * @param {object[]} sections - All the repeating section IDs
         * @param {object} casc - Expanded cascade object
         */
        const kTabOnOpen &#x3D; function({trigger,attributes,sections,casc}){
          debugger;
          persistentTabs.forEach((tabInput) &#x3D;&gt; {
            const pseudoTrigger &#x3D; {name:attributes[tabInput]};
            kSwitchTab({trigger:pseudoTrigger, attributes});
          });
        };
        registerFuncs({ kTabOnOpen },{type:[&#x27;opener&#x27;]});
        return kFuncs;
        }());
        const actionAttributes &#x3D; [];&lt;/script&gt;</code></pre>
          </div>
        </section>    </main>
    <aside>
      <h2>Mixins</h2>
      <nav>
        <ul id="toc-target">
            <li><a href="#adaptiveTextarea">adaptiveTextarea</a></li>            <li><a href="#adaptiveInput">adaptiveInput</a></li>            <li><a href="#img">img</a></li>            <li><a href="#span">span</a></li>            <li><a href="#div">div</a></li>            <li><a href="#button">button</a></li>            <li><a href="#action">action</a></li>            <li><a href="#navButton">navButton</a></li>            <li><a href="#roller">roller</a></li>            <li><a href="#compendiumAttributes">compendiumAttributes</a></li>            <li><a href="#fillLeft">fillLeft</a></li>            <li><a href="#input">input</a></li>            <li><a href="#text">text</a></li>            <li><a href="#collapse">collapse</a></li>            <li><a href="#number">number</a></li>            <li><a href="#range">range</a></li>            <li><a href="#hidden">hidden</a></li>            <li><a href="#textarea">textarea</a></li>            <li><a href="#select">select</a></li>            <li><a href="#fieldset">fieldset</a></li>            <li><a href="#inlineFieldset">inlineFieldset</a></li>            <li><a href="#button-label">button-label</a></li>            <li><a href="#roller-label">roller-label</a></li>            <li><a href="#action-label">action-label</a></li>            <li><a href="#select-label">select-label</a></li>            <li><a href="#input-label">input-label</a></li>            <li><a href="#headedTextarea">headedTextarea</a></li>            <li><a href="#SetSystemPrefix">SetSystemPrefix</a></li>            <li><a href="#attrTitle">attrTitle</a></li>            <li><a href="#buttonTitle">buttonTitle</a></li>            <li><a href="#script">script</a></li>            <li><a href="#kscript">kscript</a></li>        </ul>
      </nav>
    </aside>
    <div class="footer"></div>
    <footer>
      <section class="flex flex--space-evenly" aria-label="Contact &amp; Feedback" id="contact-header"><a class="social-icon" href="https://discord.gg/vYmvFBZQsM">discord</a><a class="social-icon" href="https://www.linkedin.com/in/scott-casey-20210398/">linkedin</a><a class="social-icon" href="https://www.patreon.com/kurohyoustudios?fan_landing=true">patreon</a>
        <div class="flex flex-column"><span style="justify-self:center;">Scott Casey | Kurohyou Studios</span><span style="justify-self:center;">06/19/2022</span></div><a class="material-icons" title="Email" href="mailto:scaseydv@gmail.com?subject=Inquiring about your work">email</a><a class="social-icon" href="https://github.com/Kurohyou">github</a><a class="social-icon" href="https://twitter.com/Kurohyoustudios">twitter</a>
      </section>
    </footer>
    <script type="text/javascript">const siteVersion = 1.1;
      
    </script>
    <script src="./assets/javascript/resizer.js"></script>
    <script src="./assets/javascript/prettify.js"></script>
    <script src="./assets/javascript/parser.js"></script>
  </body>
</html>